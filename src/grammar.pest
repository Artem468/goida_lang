WHITESPACE = _{ " " | "\t" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ NEWLINE? }

// === Program structure ===
program = { SOI ~ (NEWLINE | COMMENT)* ~ item* ~ (NEWLINE | COMMENT)* ~ EOI }
item = _{ 
    (NEWLINE | COMMENT)* ~
    (import_stmt | function | class | statement) ~
    (NEWLINE | COMMENT)*
}

// === Import statements ===
import_stmt = {
    "подключить" ~ import_list ~ ";"
}

import_list = {
    (NEWLINE | COMMENT)* ~ string_literal ~ ((NEWLINE | COMMENT)* ~ "," ~ (NEWLINE | COMMENT)* ~ string_literal)* ~ (NEWLINE | COMMENT)*
}

// === Functions ===
function = {
    "функция" ~ identifier ~ "(" ~ param_list? ~ ")" ~ return_type? ~ block
}

// === Classes ===
class = {
    "класс" ~ identifier ~ "{" ~ (NEWLINE | COMMENT)* ~ (class_item ~ (NEWLINE | COMMENT)*)* ~ "}"
}

class_item = _{
    class_field |
    constructor |
    class_method
}

class_field = {
    visibility? ~ static_mod? ~ identifier ~ ":" ~ type_name ~ ("=" ~ expression)? ~ ";"
}

constructor = {
    visibility? ~ "конструктор" ~ identifier ~ "(" ~ param_list? ~ ")" ~ return_type? ~ block
}

class_method = {
    visibility? ~ static_mod? ~ "функция" ~ identifier ~ "(" ~ param_list? ~ ")" ~ return_type? ~ block
}

// === Statements ===
statement = _{
    assignment |
    property_assign |
    if_stmt |
    while_stmt |
    for_stmt |
    return_stmt |
    expr_stmt
}

assignment = {
    identifier ~ type_hint? ~ "=" ~ expression ~ ";"
}

property_assign = {
    postfix ~ "=" ~ expression ~ ";"
}

if_stmt = {
    "если" ~ "(" ~ expression ~ ")" ~ block ~ (NEWLINE | COMMENT)* ~ else_clause?
}

else_clause = {
    "иначе" ~ (NEWLINE | COMMENT)* ~ (else_if_clause | block)
}

else_if_clause = {
    if_stmt
}

while_stmt = {
    "пока" ~ "(" ~ expression ~ ")" ~ block
}

for_stmt = {
    "для" ~ "(" ~ for_init ~ ";" ~ for_condition ~ ";" ~ for_update ~ ")" ~ block
}

for_init = {
    identifier ~ "=" ~ expression
}

for_condition = {
    expression
}

for_update = {
    compound_assign | assignment_expr | expression
}

assignment_expr = {
    identifier ~ "=" ~ expression
}

compound_assign = {
    identifier ~ compound_op ~ expression
}

compound_op = @{
    "+=" | "-=" | "*=" | "/="
}

return_stmt = {
    "вернуть" ~ expression? ~ ";"
}

expr_stmt = {
    expression ~ ";"
}

// === Expressions ===
expression = {
    logical_or
}

logical_or = {
    logical_and ~ ("или" ~ logical_and)*
}

logical_and = {
    comparison ~ ("и" ~ comparison)*
}

comparison = {
    addition ~ (comp_op ~ addition)*
}

addition = {
    multiplication ~ (add_op ~ multiplication)*
}

multiplication = {
    unary ~ (mul_op ~ unary)*
}

unary = {
    unary_op? ~ postfix
}

postfix = {
    primary ~ postfix_op*
}

postfix_op = _{
    method_call |
    function_call |
    property_access |
    index_access
}

function_call = {
    "(" ~ arg_list? ~ ")"
}

method_call = {
    "." ~ identifier ~ "(" ~ arg_list? ~ ")"
}

property_access = {
    "." ~ identifier
}

index_access = {
    "[" ~ expression ~ "]"
}

// === Primary expressions ===
primary = _{
    paren_expr |
    new_expr |
    string_literal |
    number_literal |
    bool_literal |
    empty_literal |
    this_expr |
    identifier
}

this_expr = {
    "это"
}

empty_literal = @{
    "пустота"
}

paren_expr = {
    "(" ~ expression ~ ")"
}

new_expr = {
    "новый" ~ qualified_name ~ "(" ~ arg_list? ~ ")"
}

qualified_name = {
    identifier ~ ("." ~ identifier)*
}

bool_literal = @{
    "истина" | "ложь"
}

// this - это самостоятельное слово, не часть выражения
// Используется только в property_assign как "это.поле"

// === Terminals ===
block = {
    "{" ~ (NEWLINE | COMMENT)* ~ (item ~ (NEWLINE | COMMENT)*)* ~ "}"
}

param_list = {
    (NEWLINE | COMMENT)* ~ param ~ ((NEWLINE | COMMENT)* ~ "," ~ (NEWLINE | COMMENT)* ~ param)* ~ (NEWLINE | COMMENT)*
}

param = {
    identifier ~ (":" ~ type_name)?
}

arg_list = {
    (NEWLINE | COMMENT)* ~ expression ~ ((NEWLINE | COMMENT)* ~ "," ~ (NEWLINE | COMMENT)* ~ expression)* ~ (NEWLINE | COMMENT)*
}

type_hint = {
    ":" ~ type_name
}

return_type = {
    "->" ~ type_name
}

type_name = @{
    identifier
}

static_mod = @{ "статичный" }

visibility = @{
    "публичный" | "приватный"
}

identifier = @{
    (LETTER | "_") ~ (LETTER | DIGIT | "_")*
}

string_literal = @{
    "\"" ~ (!"\"" ~ ANY)* ~ "\""
}

number_literal = @{
    DIGIT+ ~ ("." ~ DIGIT+)?
}

comp_op = @{
    "<=" | ">=" | "==" | "!=" | "<" | ">"
}

add_op = @{
    "+" | "-"
}

mul_op = @{
    "*" | "/" | "%"
}

unary_op = @{
    "-" | "!"
}

DIGIT = _{
    '0'..'9'
}
