use crate::ast::prelude::{
    AstArena, ExpressionKind, StatementKind, LiteralValue, BinaryOperator, Span,
    ExprId, StmtId, TypeId, Program, Parameter, FunctionDefinition
};
use string_interner::{DefaultSymbol as Symbol};

grammar<'program>(program: &'program mut Program);


pub Program: Vec<StmtId> = {
    <stmts:Stmt+> => stmts.into_iter().filter_map(|s| {
        match s {
            Some(_s) => program.statements.push(_s),
            None => ()
        }
        s
    }).collect(),
};


Stmt: Option<StmtId> = {
    Assign => Some(<>),
    IfBlock => Some(<>),
    WhileLoop => Some(<>),
    ForLoop => Some(<>),
    Print => Some(<>),
    Input => Some(<>),
    FunctionDef => Some(<>),
    ReturnStmt => Some(<>),
    Comment => None,
    <expr:Expression> => {
        if expr == 0 {
            None
        } else {
            Some(program.arena.add_statement(StatementKind::Expression(expr), Span::default()))
        }
    },
};


Assign: StmtId = {
    <name:r"[\p{L}_][\p{L}\p{N}_]*"> "=" <value:Expression> ";" => {
        let sym = program.arena.intern_string(name);
        program.arena.add_statement(
            StatementKind::Assign {
                name: sym,
                value,
            },
            Span::default(),
        )
    }
};


FunctionDef: StmtId = {
    "функция" <name:r"[\p{L}_][\p{L}\p{N}_]*">
        "(" <params:ParamList> ")" <ret:ReturnType?> <body:Block> => {

        let sym_name: Symbol = program.arena.intern_string(name);

        // Конвертация параметров в Parameter (через арену)
        let params_final: Vec<_> = params.into_iter().map(|(n, t)| {
            let sym = program.arena.intern_string(&n);
            let ty = match t {
                Some(type_name) => program.arena.resolve_or_intern_type(&type_name),
                None => program.arena.resolve_or_intern_type("неизвестно"),
            };
            Parameter {
                name: sym,
                param_type: ty,
                span: Span::default(),
            }
        }).collect();

        let ret_type: Option<TypeId> = match ret {
            Some(rname) => Some(program.arena.resolve_or_intern_type(&rname)),
            None => None,
        };

        let body_id = program.arena.add_statement(
            StatementKind::Block(body),
            Span::default(),
        );

        let func_def = FunctionDefinition {
            name: sym_name,
            params: params_final,
            return_type: ret_type,
            body: body_id,
            span: Span::default(),
            module: None,
        };

        program.arena.add_statement(
            StatementKind::FunctionDefinition(func_def),
            Span::default(),
        )
    }
};

ParamList: Vec<(String, Option<String>)> = {
    <first:Param> <rest:ParamTail*> => {
        let mut v = vec![first];
        v.extend(rest);
        v
    },
    => vec![],
};

ParamTail: (String, Option<String>) = {
    "," <p:Param> => p
};

Param: (String, Option<String>) = {
    <name:r"[\p{L}_][\p{L}\p{N}_]*"> ":" <typ:r"[\p{L}_][\p{L}\p{N}_]*"> => (name.to_string(), Some(typ.to_string())),
    <name:r"[\p{L}_][\p{L}\p{N}_]*"> => (name.to_string(), None)
};


ReturnType: String = {
    ":" <typ:r"[\p{L}_][\p{L}\p{N}_]*"> => typ.to_string(),
};


ReturnStmt: StmtId = {
    "вернуть" <expr:Expression?> ";" => {
        program.arena.add_statement(
            StatementKind::Return(expr),
            Span::default()
        )
    }
};

IfBlock: StmtId = {
    "если" "(" <cond:Expression> ")" <then:Block> <else_:ElseOpt> => {
        let then_id = program.arena.add_statement(StatementKind::Block(then), Span::default());
        let else_id = else_.map(|b| program.arena.add_statement(StatementKind::Block(b), Span::default()));
        program.arena.add_statement(
            StatementKind::If {
                condition: cond,
                then_body: then_id,
                else_body: else_id,
            },
            Span::default(),
        )
    }
};


ElseOpt: Option<Vec<StmtId>> = {
    => None,
    "иначе" <body:ElseBody> => Some(body),
};


ElseBody: Vec<StmtId> = {
    <stmts:Block> => stmts,
    IfBlock => vec![<>],
};


WhileLoop: StmtId = {
    "пока" "(" <cond:Expression> ")" <body:Block> => {
        let body_id = program.arena.add_statement(StatementKind::Block(body), Span::default());
        program.arena.add_statement(
            StatementKind::While {
                condition: cond,
                body: body_id,
            },
            Span::default(),
        )
    }
};


ForLoop: StmtId = {
    "для" "(" <var:r"[\p{L}_][\p{L}\p{N}_]*"> "=" <start:Expression> ";" <end:Expression> ")" <body:Block> => {
        let sym = program.arena.intern_string(var);
        let body_id = program.arena.add_statement(StatementKind::Block(body), Span::default());
        program.arena.add_statement(
            StatementKind::For {
                variable: sym,
                start,
                end,
                body: body_id,
            },
            Span::default(),
        )
    }
};


Block: Vec<StmtId> = {
    "{" <stmts:Stmt*> "}" => stmts.into_iter().flatten().collect(),
};


Print: StmtId = {
    "печать" "(" <data:Expression> ")" ";" => {
        program.arena.add_statement(
            StatementKind::Print(data),
            Span::default()
        )
    }
};


Input: StmtId = {
    "ввод" "(" <data:Expression> ")" ";" => {
        program.arena.add_statement(
            StatementKind::Input(data),
            Span::default()
        )
    }
};


Expression: ExprId = {
    <l:AddSub> "<" <r:AddSub>  => program.arena.add_expression(
        ExpressionKind::Binary { op: BinaryOperator::Lt, left: l, right: r }, Span::default()
    ),
    <l:AddSub> ">" <r:AddSub>  => program.arena.add_expression(
        ExpressionKind::Binary { op: BinaryOperator::Gt, left: l, right: r }, Span::default()
    ),
    <l:AddSub> "<=" <r:AddSub> => program.arena.add_expression(
        ExpressionKind::Binary { op: BinaryOperator::Le, left: l, right: r }, Span::default()
    ),
    <l:AddSub> ">=" <r:AddSub> => program.arena.add_expression(
        ExpressionKind::Binary { op: BinaryOperator::Ge, left: l, right: r }, Span::default()
    ),
    <l:AddSub> "==" <r:AddSub> => program.arena.add_expression(
        ExpressionKind::Binary { op: BinaryOperator::Eq, left: l, right: r }, Span::default()
    ),
    <l:AddSub> "!=" <r:AddSub> => program.arena.add_expression(
        ExpressionKind::Binary { op: BinaryOperator::Ne, left: l, right: r }, Span::default()
    ),
    AddSub,
};


AddSub: ExprId = {
    <l:MulDiv> "+" <r:AddSub> => program.arena.add_expression(
        ExpressionKind::Binary { op: BinaryOperator::Add, left: l, right: r }, Span::default()
    ),
    <l:MulDiv> "-" <r:AddSub> => program.arena.add_expression(
        ExpressionKind::Binary { op: BinaryOperator::Sub, left: l, right: r }, Span::default()
    ),
    MulDiv,
};


MulDiv: ExprId = {
    <l:Factor> "*" <r:MulDiv> => program.arena.add_expression(
        ExpressionKind::Binary { op: BinaryOperator::Mul, left: l, right: r }, Span::default()
    ),
    <l:Factor> "/" <r:MulDiv> => program.arena.add_expression(
        ExpressionKind::Binary { op: BinaryOperator::Div, left: l, right: r }, Span::default()
    ),
    Factor,
};


Factor: ExprId = {
    r#""([^"\\]|\\.)*""# => {   // Строковый литерал
        let s = &<>[1..<>.len()-1]; // убираем кавычки
        let sym = program.arena.intern_string(s); // регистрируем в арене
        program.arena.add_expression(ExpressionKind::Literal(LiteralValue::Text(sym)), Span::default())
    },
    r"[0-9]+" => {
        let num: i64 = <>.parse().unwrap();
        program.arena.add_expression(ExpressionKind::Literal(LiteralValue::Number(num)), Span::default())
    },
    r"[0-9]+\.[0-9]+" => {
        let num: f64 = <>.parse().unwrap();
        program.arena.add_expression(ExpressionKind::Literal(LiteralValue::Float(num)), Span::default())
    },
    r"[\p{L}_][\p{L}\p{N}_]*" => {
        let sym = program.arena.intern_string(<>);
        program.arena.add_expression(ExpressionKind::Identifier(sym), Span::default())
    },
    "(" <e:Expression> ")" => e,
};


Comment: () = { r"//[^\n]*" => () };
